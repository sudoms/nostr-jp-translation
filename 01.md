# NIP-01: 基本的なプロトコルフローの記述

`draft` `mandatory` `author:fiatjaf` `author:distbit` `author:scsibug` `author:kukks` `author:jb55`

本 NIP は、全てのツールが実装すべき基本的なプロトコルを定義する。
これ以降のプロトコルは、必須ないしオプションのフィールドとメッセージを新たに付加するものであり、
ここで述べているデータ構造とフローに、新たな特性を加えることが可能である。

----

## Events and signatures

各ユーザーは鍵ペアを持つ。
署名、公開鍵、およびそれらが従うエンコーディングは「[secp256k1 楕円曲線上での Schnorr 署名の標準](https://bips.xyz/340)」に準拠する。

これに関する唯一のオブジェクト（訳注：つまり Nostr の通信でやりとりされる基本データ）が `event` であり、
ネットワーク上では以下のフォーマットで表される。

```json
{
  "id": <シリアル化された "event" データ、32 バイト sha256 形式で>,
  "pubkey": <イベント作者の公開鍵を 32 バイトで十六進数エンコードして記載>,
  "created_at": <秒単位の unix タイムスタンプ>,
  "kind": <整数>,
  "tags": [
    ["e", <他のイベントの id、32 バイト十六進数で>, <リレー経路として投稿者が推奨する URL>],
    ["p", <鍵、32 バイト十六進数で>, <リレー経路として投稿者が推奨する URL>],
    ... // 他のタグも後日ここに含まれる可能性がある
  ],
  "content": <任意の文字列>,
  "sig": <シリアル化されたイベントデータの sh256 ハッシュ（= "id" フィールド）の 64 バイト署名。>
}
```
> 訳注：`"e"` タグおよび `"p"` タグについて詳しくは `NIP-10` を参照。

上記 `event` オブジェクトの `id` キーに入れるべきデータ（`event.id`）を取得するには、シリアル化されたイベントの sha256 を計算すればいい。シリアル化は、以下の構造を持つ UTF-8 JSON 文字列（ただし空白や改行は抜くこと） に対して行う。

```json
[
  0,
  <pubkey（小文字の 16 進文字列で与える）>,
  <created_at（数値で与える）>,
  <kind（数値で与える>,
  <tags（null でない文字列の配列を、さらに配列化したものとして与える）>,
  <content（文字列として与える）>
]
```

> 訳注：`jeffthibault/python-nostr` の Python 実装を見ると `create_at` と `kind` は int で定義するらしい。`create_at` はシステムタイムを `int(time.time())` で取得すればいい。
> また `event.id` を作るには、`json.dump()` で配列や辞書を JSON 形式にした後 `.encode()` メソッドでシリアル化し、`hashlib.sha256` でハッシュを計算する。

----

## クライアントとリレーの間の通信

リレーは、クライアントが接続可能な WebSocket のエンドポイントを公開する。

### クライアント→リレー：イベントの送信とサブスクリプションの作成

クライアントが送信できるメッセージは（標準では）3 種類ある。
いずれも JSON 配列でなければならず、以下のパターンに準拠する。

* `["EVENT", <上で定義した "event" の JSON>]` イベントを公開するために用いられる。
* `["REQ", <subscription_id>, <filters JSON>...]` 他ユーザーからのイベントの取得をリクエストし、新たな更新へのサブスクリプションを行うために用いられる。
* `["CLOSE", <subscription_id>]` サブスクリプションを停止するために用いられる。

上記の `<subscription_id>` は、サブスクリプションを表現するために用いられるランダムな文字列である。

当該サブスクリプションで、どのイベントが送信されるかを決定する JSON オブジェクトが `<filters>` である。
フィルターは以下のような属性を有する。

```json
{
  "ids": <イベント id もしくは接頭辞を並べたリスト>,
  "authors": <pubkeys もしくは接頭辞をまとめたリスト。各イベントに対応する pubkey は、このリストに含まれている必要がある>,
  "kinds": <"kind" の数値をまとめたリスト>,
  "#e": <ひとつの "e" タグで参照されるイベント ID をまとめたリスト>,
  "#p": <ひとつの "p" タグで参照される pubkey をまとめたリスト>,
  "since": <タイムスタンプ。これ以降のイベントのみがフィルターをパスする>,
  "until": <タイムスタンプ。これ以前のイベントのみがフィルターをパスする>,
  "limit": <初回のクエリの結果、リレーから返ってくるイベント数の上限>
}
```

`REQ` メッセージを受信したリレーは、内部データベースにクエリを実行し、フィルターに一致するイベントを返す必要がある。さらにそのフィルターを保存し、Websocket が閉じられるまでの間は同じ Websocket に受信する全イベントを、再度送信することになる。 `CLOSE` イベントは同じ `<subscription_id>` を用いて受信されるか、もしくは同じ `<subscription_id>` への新しい `REQ` として送信されことになる。後者の場合、以前のサブスクリプションが上書きされる。

リストを含むフィルター属性（`ids`、`kinds`、または `#e` など）は、1 つ以上の値を持つ JSON 配列である。条件自体が一致していると見なされるには、配列の値の少なくとも 1 つがイベントの関連するフィールドと一致する必要がある。 `kind` のようにスカラーで表されるイベント属性の場合、そのイベントの属性がフィルターリストに含まれている必要がある。`#e` のように、1 つのイベントが複数の値を持ちうるタグ属性の場合、イベントとフィルター条件の値の間で、少なくとも 1 つの共通項目を持つ必要がある。

`ids` および `authors` リストには、小文字の 16 進数文字列が含まれる。
これは 64 文字（= ユーザー ID である公開鍵の全長）による正確なマッチか、
あるいはイベントの値の接頭辞（訳注：すなわち冒頭一致）のいずれかである。
接頭辞によるマッチは、フィルター文字列がイベント値の正確な文字列の冒頭部である場合に一致とみなされる。
接頭辞を使用することで、たくさんの値についてクエリを実行する際のフィルターをより小型化できる。
さらに検索したいイベントやその作成者について、リレー側に情報を漏らしたくないクライアントに、
ある程度のプライバシーを提供できる。

イベントがフィルタをパスするには、指定されたフィルタの条件が全て真である必要がある。
すなわち、1 つのフィルタ内で複数の絞り込み条件を指定した場合には `&&` 条件として解釈される。

一方で `REQ` メッセージは、複数のフィルタを含むことがある。
この場合、いずれかのフィルターにおいて真であるイベントが返る。
すなわち、複数のフィルターは `||` 条件として解釈される。

フィルタの `limit` プロパティは（少なくとも）最初のクエリ実行時のみ有効と規定されており、
その後は無視されることがある。 
`limit: n` が存在する場合、最新の `n` イベントが最初のクエリで返されるという挙動が想定される。
`limit` の指定値よりも少ない数のイベントを返すほうが安全性は高い。
とはいえ、クライアントが不必要に大量な受信データのせいで逼迫しないために、
リクエストされた量を上回りすぎない程度のデータを返すようにリレーを設計することが望ましい。

### リレー→クライアント：イベントと通知の送信

リレーは以下のパターンに従い、2 種類のメッセージ（JSON 配列である必要）を送信できる。

* `["EVENT", <subscription_id>, <上で定義した event の JSON>]` クライアントから要求されたイベントを送信するために用いられる。
* `["NOTICE", <message>]` エラーメッセージその他の情報を、人間が可読な形式でクライアントに送信するために用いられる。

この NIP では、"NOTICE" メッセージの送信方法や処理方法に関するルールは定義しない。

`EVENT` メッセージは必ず、クライアントからのリクエスト（上記 `REQ` メッセージ）
によって開始済みのサブスクリプションに紐づいた、`subscription_id` と共に送信されねばならない。

> 訳注：つまりリレー側が、任意の未登録／登録解除済みユーザーに広告を送りつけるような運用は認められない。
仮にそのようなメッセージが来ても、クライアント側で容易にスパムとして識別できるため破棄されるだろう。

----

## 基本イベントの種類

- `0`: `set_metadata`: このイベントの `content` 属性は、当該イベントを作成したユーザーを記述するための、文字列化された JSON オブジェクトである `{name: <username>, about: <string>, picture: <url, string>}` に対して設定される。リレーは、同じ公開鍵の新しいイベントを取得した後であれば、古い `set_metadata` イベントを削除してもよい。

- `1`: `text_note`: このイベントの `content` 属性は、メモの内容であるテキスト部分（ユーザーが言いたいこと）を指す。[NIP-16](16.md) で説明するように、非平文のメモに対しては kind 1 ではなく、kind 1000-10000 を使う必要がある。

- `2`: `recommend_server`: このイベントの `content` 属性は、イベント作成者がフォロワーに推奨するリレーの URL（例：`https://somerelay.com`）を指す。

リレーによっては、異なる種類のメッセージを異なる方法で処理する場合があり、サポートされていない種類のメッセージ処理する際に、デフォルトの方法を選択しないかもしれない。

## その他の注意事項:

- クライアントが各リレーに対して開く Websocket の数は 1 個だけに留めること。
1 つのチャンネルでも無制限の数のサブスクリプションをサポートできるので、クライアントはそうするべきである。

- `tags` 配列の各サブ配列では、最初の要素としてタグ識別子を格納でき、
その後に任意の情報を（必ず文字列として）格納することが可能である。
特に NIP-1 では `"p"`（pubkey の意。そのイベントで参照されている誰かの公開鍵を指定する）および、
`"e"`（event の意。当該イベントが引用、返信、ないし参照する対象のイベント ID を指定する）
というタグ識別子が定義されている。

- `"e"` および `"p"` タグに含まれる `<recommended relay URL>` アイテムは、タグ付けされたイベント（あるいはタグ付けされたプロファイルから発信された他の情報）を取得するために、クライアントが接続を試みるリレーの URL を、オプションで指定するものである（未指定すなわち `""` でも可）。これはクライアントによって無視されるかもしれないが、検閲への耐性を高め、リレー先のアドレスをクライアント間でシームレスに拡散するために存在している。

